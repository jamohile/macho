![logo](https://user-images.githubusercontent.com/17712692/100533843-e46c5780-31d6-11eb-99db-1ae735e46ce9.png)

# Macho
State that doesn't suck.

## What is Macho?
Macho is a state manager. It lets you build stores of application state anywhere in your app, that any other part of your app can subscribe to.

There's other tools that do this, here's what makes Macho special.

- **Very** quick to get started. You can get as advanced as you like, but getting started takes < 5 lines of code.
- **Flexible** enough to be used from anywhere in your app. UI, logic, wherever.
- **Simple**. Some other state-management tools take files and files of boilerplate, to the point that you try to avoid using them unless absolutely necessary. Macho isn't like that.
- **Powerful**.

## Getting started
Let's say we just want a simple piece of application state. Nothing fancy, just something we can read/write from across the app...maybe the user's name.

```typescript
import {Macho} from "macho"

const name = new Macho();
```

That's it! Anywhere else in the app, we can set this using
```typescript
name.set("Elon")
```

If we want to listen for changes, we can subscribe to it.
```typescript
const unsubscribe = name.subscribe(value => {
  // This function will be called on every change.
});
```
`unsubscribe` is another function generated by Macho, call it to unsubscribe your listener when you're done with it. 

### Hooks
If you're using React, this is even easier.

```jsx
const myAwesomeComponent = () => {
  const name = useMacho(name);

  return (
    <div>{name}</div>
  )
}
```

## Continuing on...
Sometimes in your app, you don't **need** the latest version of something through a listener. In these cases, you can always access the last version of the data with `name.lastData()`. 

## Now for the cool stuff.

### Dependent State
Let's say you have some application state that depends on other parts. For example, you have a user's name, their nickname, and their display name. All separate. You'd like to format them for reuse all over the place, while keeping them separate.

```typescript
const name = new Macho();
const nickname = new Macho();

const displayName = new Macho({
  worker: set => {
    set(`${name} a.k.a ${nickname}`);
  },
  dependencies: [name, nickname]
});
```
Now, displayName (and all its listeners) are automatically synced to changes in name and nickname. Is this a contrived example? Absolutely. But this type of problem comes up in real apps all the time, and Macho makes it simple.

## Async Listeners and Resource Sharing

Let's take a closer look at that `worker` function we just used. This is what makes Macho so powerful. In the case above, it was simple...a pure function that responds to changes in some dependencies.

But, let's say we're getting live synced data from a service like firebase.

```typescript
const todoItems = new Macho({
  worker: set => {
    // Have your listener here.
    const unsubscribe = mydb.listen("todos", list => {
      set(list);
    });
    // Return a cleanup function that Macho will call when this item is done.
    return () => unsubscribe();
  }
});

// All of these share the same underlying listener,
// So only one call is actually made to the server!
// Macho is smart enough to automatically provision
// and deprovision the underlying listeners.
todoItems.subscribe(....)
toDoItems.subscribe(....)
toDoItems.subscribe(....) //etc
```

## Smoothing
Sometimes, especially with something like react, changes to your UI mean the same listeners get stopped/started multiple times, simply because the UI re-rendered. This can mean more load on your servers. Macho fixes this with something called smoothing.

The basic idea? Generally, when there are no subscriptions left for a listener, Macho will deactivate it. When objects subscribe again, Macho will reactive it. However, you can tell Macho to wait for some amount of time **before** deactivating it. This way, if subscriptions come back on line faster than that, they'll just use the old listener.

```typescript
const name = new Macho({
  ...
  workerProps: {
    delayShutdown: 1000 // Wait 1 second before shutting down listeners.
  }
})
```

## Persistence
Some pieces of app data, you don't want to 'stop listening'. You'd like to keep track of them in the background even when nobody is listening. For these, you can enable **persistence**. This just means Macho will keep listening, just in case.

```typescript
const name = new Macho({
  ...
  workerProps: {
    persist: true
  }
})
```
> Note, this also means Macho will turn on the listener right away.


